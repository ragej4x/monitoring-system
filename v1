#include <WiFiS3.h>
#include <ArduinoJson.h>
#include <OneWire.h>
#include <DallasTemperature.h>

// Pin definitions
const int waterPumpPin = 13;
const int solutionAPin = 12;  // Pump A
const int solutionBPin = 8;   // Pump B
const int solutionCPin = 7;   // Pump C
const int solutionDPin = 4;   // Pump D

// Sensor pins
const int floaterSwitchPin = A3;  // From floatswitch.ino
const int phSensorPin = A0;       // From ph_sensor.ino
const int tdsSensorPin = A1;      // From tdsmeter.ino
const int temperatureSensorPin = 2; // From tempsen.ino

// OneWire setup for DS18B20 temperature sensor
OneWire oneWire(temperatureSensorPin);
DallasTemperature sensors(&oneWire);

// TDS Sensor Variables (from tdsmeter.ino)
#define VREF 5.0              // analog reference voltage(Volt) of the ADC
#define SCOUNT 30             // sum of sample point
int analogBuffer[SCOUNT];     // store the analog value in the array, read from ADC
int analogBufferTemp[SCOUNT];
int analogBufferIndex = 0;
int copyIndex = 0;
float temperature = 25;       // current temperature for compensation

// pH Sensor Variables (from ph_sensor.ino)
float calibration_value = 21.34;
int phval = 0; 
unsigned long int avgval; 
int buffer_arr[10], temp;

// Timing variables
unsigned long lastSensorReadTime = 0;
const unsigned long sensorReadInterval = 5000; // Read sensors every 5 seconds

// WiFi credentials
#define WIFI_SSID "PLDTHOMEFIBRb8900"
#define WIFI_PASSWORD "#Fk9lratv123456789"

// Firebase credentials
#define FIREBASE_HOST "iot-monitoringsys-default-rtdb.asia-southeast1.firebasedatabase.app"
#define FIREBASE_AUTH "Bfblx5ubfwbbPw6vbM13Scw3zGdDw6iZPOgV3RaW"

// Use WiFiSSLClient for HTTPS instead of standard WiFiClient
WiFiSSLClient client;

// Configuration variables
int ph_limit = 14;  // Default max pH value
int ppm_limit = 0;  // No default max PPM value
int ph_min = -3;    // Default min pH value
int ppm_min = 10;   // Default min PPM value
int scan_interval = 1; // Default scan interval in minutes
int fail_safe = 0;

// Pump activation timers
unsigned long pumpAStartTime = 0;
unsigned long pumpBStartTime = 0;
unsigned long pumpCStartTime = 0;
unsigned long pumpDStartTime = 0;
bool pumpARunning = false;
bool pumpBRunning = false;
bool pumpCRunning = false;
bool pumpDRunning = false;

// Function to read temperature from DS18B20 sensor (from tempsen.ino)
float readTemperature() {
  sensors.requestTemperatures();
  float celsius = sensors.getTempCByIndex(0);
  
  // Error handling in case sensor isn't connected properly
  if (celsius == -127.00) {
    return 25.0; // Return default value if sensor error
  }
  
  return celsius;
}

// Function to read pH value (from ph_sensor.ino)
float readPh() {
  for (int i = 0; i < 10; i++) { 
    buffer_arr[i] = analogRead(phSensorPin);
    delay(10);
  }

  // Sort the analog readings
  for (int i = 0; i < 9; i++) {
    for (int j = i + 1; j < 10; j++) {
      if (buffer_arr[i] > buffer_arr[j]) {
        temp = buffer_arr[i];
        buffer_arr[i] = buffer_arr[j];
        buffer_arr[j] = temp;
      }
    }
  }

  avgval = 0;
  for (int i = 2; i < 8; i++) {
    avgval += buffer_arr[i];
  }

  float volt = (float)avgval * 5.0 / 1024 / 6;
  float ph_act = -5.70 * volt + calibration_value;
  
  return ph_act;
}

// Median filtering algorithm (from tdsmeter.ino)
int getMedianNum(int bArray[], int iFilterLen) {
  int bTab[iFilterLen];
  for (byte i = 0; i < iFilterLen; i++)
    bTab[i] = bArray[i];
    
  int i, j, bTemp;
  for (j = 0; j < iFilterLen - 1; j++) {
    for (i = 0; i < iFilterLen - j - 1; i++) {
      if (bTab[i] > bTab[i + 1]) {
        bTemp = bTab[i];
        bTab[i] = bTab[i + 1];
        bTab[i + 1] = bTemp;
      }
    }
  }
  
  if ((iFilterLen & 1) > 0) {
    bTemp = bTab[(iFilterLen - 1) / 2];
  } else {
    bTemp = (bTab[iFilterLen / 2] + bTab[iFilterLen / 2 - 1]) / 2;
  }
  
  return bTemp;
}

// Function to read TDS value (from tdsmeter.ino)
int readPpm() {
  static unsigned long analogSampleTimepoint = millis();
  
  // Read samples
  if(millis() - analogSampleTimepoint > 40) {
    analogSampleTimepoint = millis();
    analogBuffer[analogBufferIndex] = analogRead(tdsSensorPin);
    analogBufferIndex++;
    if(analogBufferIndex == SCOUNT) {
      analogBufferIndex = 0;
    }
  }
  
  // Process PPM reading
  for(copyIndex = 0; copyIndex < SCOUNT; copyIndex++) {
    analogBufferTemp[copyIndex] = analogBuffer[copyIndex];
  }
  
  // Get median and convert to voltage
  float averageVoltage = getMedianNum(analogBufferTemp, SCOUNT) * (float)VREF / 1024.0;
  
  // Temperature compensation
  float compensationCoefficient = 1.0 + 0.02 * (temperature - 25.0);
  float compensationVoltage = averageVoltage / compensationCoefficient;
  
  // Convert voltage to PPM value
  int ppmValue = (133.42 * compensationVoltage * compensationVoltage * compensationVoltage - 
                 255.86 * compensationVoltage * compensationVoltage + 
                 857.39 * compensationVoltage) * 0.5;
                 
  return ppmValue;
}

// Function to read float switch state (from floatswitch.ino)
bool readFloatSwitch() {
  // Inverted logic: LOW pin reading means HIGH water level
  return digitalRead(floaterSwitchPin) == HIGH;
}

// Function to send log to Firebase
void sendLogToFirebase(String message) {
  if (client.connect(FIREBASE_HOST, 443)) {
    // Create timestamp
    unsigned long currentTime = millis();
    
    // Create JSON document with log message
    StaticJsonDocument<256> doc;
    doc["message"] = message;
    doc["timestamp"] = currentTime;
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    
    // Path to the logs node in Firebase with timestamp as key
    String path = "/logs/" + String(currentTime) + ".json?auth=" + String(FIREBASE_AUTH);
    
    // Send HTTP PUT request
    client.println("PUT " + path + " HTTP/1.1");
    client.println("Host: " + String(FIREBASE_HOST));
    client.println("Connection: close");
    client.println("Content-Type: application/json");
    client.print("Content-Length: ");
    client.println(jsonStr.length());
    client.println();
    client.println(jsonStr);
    
    // Wait for response
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 10000) {
        client.stop();
        return;
      }
    }
    
    // Consume the response
    while (client.available()) {
      client.read();
    }
  }
  client.stop();
}

// Function to update pump status in Firebase
void updatePumpStatusInFirebase() {
  if (client.connect(FIREBASE_HOST, 443)) {
    // Create a JSON document with current pump status
    StaticJsonDocument<256> doc;
    bool waterLevelHigh = readFloatSwitch();
    
    // For water pump, show the current state and whether it's under automatic control
    doc["water_pump"] = digitalRead(waterPumpPin) == HIGH;
    doc["water_pump_manual_control"] = false; // Default to automatic control
    
    // For solution pumps, show their current states
    doc["pump_a"] = digitalRead(solutionAPin) == HIGH;
    doc["pump_b"] = digitalRead(solutionBPin) == HIGH;
    doc["pump_c"] = digitalRead(solutionCPin) == HIGH;
    doc["pump_d"] = digitalRead(solutionDPin) == HIGH;
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    
    // Path to the pumps node in Firebase
    String path = "/pumps.json?auth=" + String(FIREBASE_AUTH);
    
    // Send HTTP PUT request to update the pumps node
    client.println("PUT " + path + " HTTP/1.1");
    client.println("Host: " + String(FIREBASE_HOST));
    client.println("Connection: close");
    client.println("Content-Type: application/json");
    client.print("Content-Length: ");
    client.println(jsonStr.length());
    client.println();
    client.println(jsonStr);
    
    // Wait for response
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 5000) {
        client.stop();
        return;
      }
    }
    
    // Consume the response
    while (client.available()) {
      client.read();
    }
  }
  client.stop();
}

// Function to check and adjust pH and PPM levels based on configured limits
void checkAndAdjustLevels(float currentPh, int currentPpm) {
  bool pumpStateChanged = false;
  bool adjustmentMade = false;
  
  // First check PPM levels
  if (ppm_min > 0) {  // Only check if min limit is configured
    if (currentPpm < ppm_min) {
      // If PPM is below minimum, activate pump A
      if (!pumpARunning) {
        digitalWrite(solutionAPin, HIGH);
        pumpAStartTime = millis();
        pumpARunning = true;
        pumpStateChanged = true;
        adjustmentMade = true;
        String message = "PPM below minimum (" + String(currentPpm) + " < " + String(ppm_min) + "). Activating Pump A.";
        Serial.println(message);
        sendLogToFirebase(message);
        
        // If we're making an adjustment, don't check pH in this cycle
        if (pumpStateChanged) {
          updatePumpStatusInFirebase();
          return;
        }
      }
    } else if (ppm_limit > 0 && currentPpm > ppm_limit) {
      // If PPM is above limit, activate pump B
      if (!pumpBRunning) {
        digitalWrite(solutionBPin, HIGH);
        pumpBStartTime = millis();
        pumpBRunning = true;
        pumpStateChanged = true;
        adjustmentMade = true;
        String message = "PPM above limit (" + String(currentPpm) + " > " + String(ppm_limit) + "). Activating Pump B.";
        Serial.println(message);
        sendLogToFirebase(message);
        
        // If we're making an adjustment, don't check pH in this cycle
        if (pumpStateChanged) {
          updatePumpStatusInFirebase();
          return;
        }
      }
    } else {
      // If PPM is within range, turn off pumps A and B
      if (pumpARunning) {
        digitalWrite(solutionAPin, LOW);
        unsigned long duration = (millis() - pumpAStartTime) / 1000; // Duration in seconds
        pumpARunning = false;
        pumpStateChanged = true;
        String message = "PPM within range. Pump A turned off after " + String(duration) + " seconds.";
        Serial.println(message);
        sendLogToFirebase(message);
      }
      
      if (pumpBRunning) {
        digitalWrite(solutionBPin, LOW);
        unsigned long duration = (millis() - pumpBStartTime) / 1000; // Duration in seconds
        pumpBRunning = false;
        pumpStateChanged = true;
        String message = "PPM within range. Pump B turned off after " + String(duration) + " seconds.";
        Serial.println(message);
        sendLogToFirebase(message);
      }
    }
  }
  
  // Only check pH levels if no PPM adjustment was made
  if (!adjustmentMade && ph_min > -4 && ph_limit > 0) {  // Only check if limits are configured
    if (currentPh < ph_min) {
      // If pH is below minimum, activate pump C (pH UP)
      if (!pumpCRunning) {
        digitalWrite(solutionCPin, HIGH);
        pumpCStartTime = millis();
        pumpCRunning = true;
        pumpStateChanged = true;
        String message = "pH below minimum (" + String(currentPh) + " < " + String(ph_min) + "). Activating Pump C (pH UP).";
        Serial.println(message);
        sendLogToFirebase(message);
      }
      
      // Ensure pump D is off when pump C is running
      if (pumpDRunning) {
        digitalWrite(solutionDPin, LOW);
        unsigned long duration = (millis() - pumpDStartTime) / 1000;
        pumpDRunning = false;
        pumpStateChanged = true;
        String message = "Turning off Pump D while adjusting pH upward.";
        Serial.println(message);
        sendLogToFirebase(message);
      }
    } else if (currentPh > ph_limit) {
      // If pH is above limit, activate pump D (pH DOWN)
      if (!pumpDRunning) {
        digitalWrite(solutionDPin, HIGH);
        pumpDStartTime = millis();
        pumpDRunning = true;
        pumpStateChanged = true;
        String message = "pH above limit (" + String(currentPh) + " > " + String(ph_limit) + "). Activating Pump D (pH DOWN).";
        Serial.println(message);
        sendLogToFirebase(message);
      }
      
      // Ensure pump C is off when pump D is running
      if (pumpCRunning) {
        digitalWrite(solutionCPin, LOW);
        unsigned long duration = (millis() - pumpCStartTime) / 1000;
        pumpCRunning = false;
        pumpStateChanged = true;
        String message = "Turning off Pump C while adjusting pH downward.";
        Serial.println(message);
        sendLogToFirebase(message);
      }
    } else {
      // If pH is within range, turn off pumps C and D
      if (pumpCRunning) {
        digitalWrite(solutionCPin, LOW);
        unsigned long duration = (millis() - pumpCStartTime) / 1000; // Duration in seconds
        pumpCRunning = false;
        pumpStateChanged = true;
        String message = "pH within range. Pump C turned off after " + String(duration) + " seconds.";
        Serial.println(message);
        sendLogToFirebase(message);
      }
      
      if (pumpDRunning) {
        digitalWrite(solutionDPin, LOW);
        unsigned long duration = (millis() - pumpDStartTime) / 1000; // Duration in seconds
        pumpDRunning = false;
        pumpStateChanged = true;
        String message = "pH within range. Pump D turned off after " + String(duration) + " seconds.";
        Serial.println(message);
        sendLogToFirebase(message);
      }
    }
  }
  
  // If any pump state changed, update Firebase
  if (pumpStateChanged) {
    updatePumpStatusInFirebase();
  }
}

// Function to read all sensors, send data to Firebase, and perform control actions
void updateSensorsAndControl(bool performControl) {
  // Turn off water pump during sensor checks if performing control
  if (performControl) {
    digitalWrite(waterPumpPin, LOW);
    Serial.println("Water pump turned OFF for sensor checks");
    delay(1000); // Longer delay to ensure pump is fully off and water settles before readings
  }
  
  // Read all sensor values one by one with small delays between readings
  // to ensure accurate readings and prevent interference
  Serial.println("Reading temperature sensor...");
  float tempValue = readTemperature();
  delay(500);
  
  Serial.println("Reading pH sensor...");
  float phValue = readPh();
  delay(500);
  
  Serial.println("Reading PPM/TDS sensor...");
  int ppmValue = readPpm();
  delay(500);
  
  Serial.println("Reading water level sensor...");
  bool waterLevelHigh = readFloatSwitch();
  
  // Update temperature for PPM compensation
  temperature = tempValue;
  
  // Log all sensor readings
  Serial.println("Sensor readings complete:");
  Serial.println("Temperature: " + String(tempValue) + "°C");
  Serial.println("pH: " + String(phValue));
  Serial.println("PPM: " + String(ppmValue));
  Serial.println("Water Level: " + String(waterLevelHigh ? "HIGH" : "LOW"));
  
  // Send data to Firebase sensors node
  if (client.connect(FIREBASE_HOST, 443)) {
    // Create JSON document with sensor values
    StaticJsonDocument<200> doc;
    doc["temperature"] = tempValue;
    doc["pH"] = phValue;
    doc["PPM"] = ppmValue;
    doc["waterLevel"] = waterLevelHigh ? "HIGH" : "LOW";
    doc["timestamp"] = millis();
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    
    // Path to the sensors node in Firebase
    String path = "/sensors.json?auth=" + String(FIREBASE_AUTH);
    
    // Send HTTP PUT request
    client.println("PUT " + path + " HTTP/1.1");
    client.println("Host: " + String(FIREBASE_HOST));
    client.println("Connection: close");
    client.println("Content-Type: application/json");
    client.print("Content-Length: ");
    client.println(jsonStr.length());
    client.println();
    client.println(jsonStr);
    
    // Wait for response - with shorter timeout
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 5000) { // Reduced timeout from 10s to 5s
        client.stop();
        return;
      }
    }
    
    // Consume the response quickly
    while (client.available()) {
      client.read();
    }
  }
  client.stop();
  
  // After sending data to Firebase, check and adjust levels if water level is high and control is requested
  if (performControl) {
    if (waterLevelHigh) {
      // Check and adjust pH and PPM levels sequentially
      Serial.println("Water level is HIGH - Starting sequential checks and adjustments");
      checkAndAdjustLevels(phValue, ppmValue);
      
      // Turn off water pump when water level is high
      digitalWrite(waterPumpPin, LOW);
      Serial.println("Water level HIGH - Water pump kept OFF");
    } else {
      // If water level is low, turn off all solution pumps for safety
      Serial.println("Water level is LOW - Turning off all solution pumps for safety");
      
      if (pumpARunning || digitalRead(solutionAPin) == HIGH) {
        digitalWrite(solutionAPin, LOW);
        pumpARunning = false;
        Serial.println("Water level LOW - Pump A turned OFF for safety");
      }
      
      if (pumpBRunning || digitalRead(solutionBPin) == HIGH) {
        digitalWrite(solutionBPin, LOW);
        pumpBRunning = false;
        Serial.println("Water level LOW - Pump B turned OFF for safety");
      }
      
      if (pumpCRunning || digitalRead(solutionCPin) == HIGH) {
        digitalWrite(solutionCPin, LOW);
        pumpCRunning = false;
        Serial.println("Water level LOW - Pump C turned OFF for safety");
      }
      
      if (pumpDRunning || digitalRead(solutionDPin) == HIGH) {
        digitalWrite(solutionDPin, LOW);
        pumpDRunning = false;
        Serial.println("Water level LOW - Pump D turned OFF for safety");
      }
      
      // Turn on water pump when water level is low
      digitalWrite(waterPumpPin, HIGH);
      Serial.println("Water level LOW - Water pump turned ON");
      
      // Update pump status in Firebase
      updatePumpStatusInFirebase();
    }
  } else {
    // If not performing control, just manage water pump based on water level
    if (waterLevelHigh) {
      digitalWrite(waterPumpPin, LOW);
    } else {
      digitalWrite(waterPumpPin, HIGH);
    }
  }
}

// Function to read pump control commands from Firebase
void readPumpCommandsFromFirebase() {
  if (client.connect(FIREBASE_HOST, 443)) {
    String path = "/pumps.json?auth=" + String(FIREBASE_AUTH);
    client.println("GET " + path + " HTTP/1.1");
    client.println("Host: " + String(FIREBASE_HOST));
    client.println("Connection: close");
    client.println();

    // Wait for response
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 5000) {
        client.stop();
        return;
      }
    }

    // Read response and extract JSON body
    String response = "";
    bool jsonStarted = false;
    String line = "";
    
    while (client.available()) {
      char c = client.read();
      
      // Look for the blank line that separates headers from body
      if (c == '\r' && line.length() == 0) {
        // Skip this character
      } else if (c == '\n' && line.length() == 0) {
        // Empty line indicates the start of the JSON body
        jsonStarted = true;
        line = "";
      } else if (jsonStarted) {
        // If we've reached the JSON body, collect characters
        response += c;
      } else if (c == '\n') {
        // Reset line when we hit a newline
        line = "";
      } else {
        // Add character to current header line
        line += c;
      }
    }

    // Parse JSON only if we have a valid response
    if (response.length() > 0) {
      StaticJsonDocument<200> doc;
      DeserializationError error = deserializeJson(doc, response);
      if (error) {
        Serial.println("JSON parsing failed: " + String(error.c_str()));
        client.stop();
        return;
      }

      // Check if any pump state has changed from Firebase commands
      bool stateChanged = false;
      bool waterLevelHigh = readFloatSwitch();
      
      // Control water pump based on Firebase command only if manual control is enabled
      bool waterPumpManualControl = doc["water_pump_manual_control"].as<bool>();
      if (waterPumpManualControl) {
        bool waterPumpState = doc["water_pump"].as<bool>();
        if (digitalRead(waterPumpPin) != (waterPumpState ? HIGH : LOW)) {
          digitalWrite(waterPumpPin, waterPumpState ? HIGH : LOW);
          stateChanged = true;
          String message = "Water pump " + String(waterPumpState ? "activated" : "deactivated") + " via Firebase command (manual control)";
          Serial.println(message);
          sendLogToFirebase(message);
        }
      } else {
        // If manual control is disabled, update Firebase with current state based on water level
        if (doc["water_pump"].as<bool>() != (waterLevelHigh ? false : true)) {
          // Update Firebase to match the automatic state
          updatePumpStatusInFirebase();
        }
      }
      
      // Only allow manual control of solution pumps if water level is high
      if (waterLevelHigh) {
        // Control solution pumps based on Firebase commands
        bool pumpAState = doc["pump_a"].as<bool>();
        // Check if the pump state in Firebase is different from the actual pin state
        // OR if we need to update the running state
        if (digitalRead(solutionAPin) != (pumpAState ? HIGH : LOW) || 
            (pumpARunning && !pumpAState) || (!pumpARunning && pumpAState)) {
          digitalWrite(solutionAPin, pumpAState ? HIGH : LOW);
          stateChanged = true;
          if (pumpAState && !pumpARunning) {
            pumpARunning = true;
            pumpAStartTime = millis();
            String message = "Pump A activated via Firebase command";
            Serial.println(message);
            sendLogToFirebase(message);
          } else if (!pumpAState && pumpARunning) {
            unsigned long duration = (millis() - pumpAStartTime) / 1000; // Duration in seconds
            pumpARunning = false;
            String message = "Pump A deactivated via Firebase command after " + String(duration) + " seconds";
            Serial.println(message);
            sendLogToFirebase(message);
          }
        }
        
        bool pumpBState = doc["pump_b"].as<bool>();
        if (digitalRead(solutionBPin) != (pumpBState ? HIGH : LOW) || 
            (pumpBRunning && !pumpBState) || (!pumpBRunning && pumpBState)) {
          digitalWrite(solutionBPin, pumpBState ? HIGH : LOW);
          stateChanged = true;
          if (pumpBState && !pumpBRunning) {
            pumpBRunning = true;
            pumpBStartTime = millis();
            String message = "Pump B activated via Firebase command";
            Serial.println(message);
            sendLogToFirebase(message);
          } else if (!pumpBState && pumpBRunning) {
            unsigned long duration = (millis() - pumpBStartTime) / 1000; // Duration in seconds
            pumpBRunning = false;
            String message = "Pump B deactivated via Firebase command after " + String(duration) + " seconds";
            Serial.println(message);
            sendLogToFirebase(message);
          }
        }
        
        bool pumpCState = doc["pump_c"].as<bool>();
        if (digitalRead(solutionCPin) != (pumpCState ? HIGH : LOW) || 
            (pumpCRunning && !pumpCState) || (!pumpCRunning && pumpCState)) {
          digitalWrite(solutionCPin, pumpCState ? HIGH : LOW);
          stateChanged = true;
          if (pumpCState && !pumpCRunning) {
            pumpCRunning = true;
            pumpCStartTime = millis();
            String message = "Pump C (pH UP) activated via Firebase command";
            Serial.println(message);
            sendLogToFirebase(message);
            
            // Turn off pump D if pump C is being activated
            if (pumpDRunning) {
              digitalWrite(solutionDPin, LOW);
              unsigned long duration = (millis() - pumpDStartTime) / 1000;
              pumpDRunning = false;
              String message = "Pump D turned off automatically when Pump C was activated";
              Serial.println(message);
              sendLogToFirebase(message);
            }
          } else if (!pumpCState && pumpCRunning) {
            unsigned long duration = (millis() - pumpCStartTime) / 1000; // Duration in seconds
            pumpCRunning = false;
            String message = "Pump C deactivated via Firebase command after " + String(duration) + " seconds";
            Serial.println(message);
            sendLogToFirebase(message);
          }
        }
        
        bool pumpDState = doc["pump_d"].as<bool>();
        if (digitalRead(solutionDPin) != (pumpDState ? HIGH : LOW) || 
            (pumpDRunning && !pumpDState) || (!pumpDRunning && pumpDState)) {
          digitalWrite(solutionDPin, pumpDState ? HIGH : LOW);
          stateChanged = true;
          if (pumpDState && !pumpDRunning) {
            pumpDRunning = true;
            pumpDStartTime = millis();
            String message = "Pump D (pH DOWN) activated via Firebase command";
            Serial.println(message);
            sendLogToFirebase(message);
            
            // Turn off pump C if pump D is being activated
            if (pumpCRunning) {
              digitalWrite(solutionCPin, LOW);
              unsigned long duration = (millis() - pumpCStartTime) / 1000;
              pumpCRunning = false;
              String message = "Pump C turned off automatically when Pump D was activated";
              Serial.println(message);
              sendLogToFirebase(message);
            }
          } else if (!pumpDState && pumpDRunning) {
            unsigned long duration = (millis() - pumpDStartTime) / 1000; // Duration in seconds
            pumpDRunning = false;
            String message = "Pump D deactivated via Firebase command after " + String(duration) + " seconds";
            Serial.println(message);
            sendLogToFirebase(message);
          }
        }
      } else {
        // If water level is low, ensure all solution pumps are off
        bool anyPumpChanged = false;
        
        if (digitalRead(solutionAPin) == HIGH) {
          digitalWrite(solutionAPin, LOW);
          pumpARunning = false;
          anyPumpChanged = true;
        }
        
        if (digitalRead(solutionBPin) == HIGH) {
          digitalWrite(solutionBPin, LOW);
          pumpBRunning = false;
          anyPumpChanged = true;
        }
        
        if (digitalRead(solutionCPin) == HIGH) {
          digitalWrite(solutionCPin, LOW);
          pumpCRunning = false;
          anyPumpChanged = true;
        }
        
        if (digitalRead(solutionDPin) == HIGH) {
          digitalWrite(solutionDPin, LOW);
          pumpDRunning = false;
          anyPumpChanged = true;
        }
        
        if (anyPumpChanged) {
          String message = "Water level LOW - All solution pumps turned OFF for safety";
          Serial.println(message);
          sendLogToFirebase(message);
          stateChanged = true;
        }
      }
      
      // If any state changed, update Firebase
      if (stateChanged) {
        updatePumpStatusInFirebase();
      }
    }
  }
  client.stop();
}

// Function to read configuration values from Firebase
void readConfigFromFirebase() {
  if (client.connect(FIREBASE_HOST, 443)) {
    String path = "/config.json?auth=" + String(FIREBASE_AUTH);
    client.println("GET " + path + " HTTP/1.1");
    client.println("Host: " + String(FIREBASE_HOST));
    client.println("Connection: close");
    client.println();

    // Wait for response
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 5000) { // Reduced timeout
        client.stop();
        return;
      }
    }

    // Read response and extract JSON body
    String response = "";
    bool jsonStarted = false;
    String line = "";
    
    while (client.available()) {
      char c = client.read();
      
      // Look for the blank line that separates headers from body
      if (c == '\r' && line.length() == 0) {
        // Skip this character
      } else if (c == '\n' && line.length() == 0) {
        // Empty line indicates the start of the JSON body
        jsonStarted = true;
        line = "";
      } else if (jsonStarted) {
        // If we've reached the JSON body, collect characters
        response += c;
      } else if (c == '\n') {
        // Reset line when we hit a newline
        line = "";
      } else {
        // Add character to current header line
        line += c;
      }
    }

    // Parse JSON only if we have a valid response
    if (response.length() > 0) {
      StaticJsonDocument<256> doc;
      DeserializationError error = deserializeJson(doc, response);
      if (error) {
        return;
      }

      // Update configuration variables
      bool configChanged = false;
      
      // Check if pH limit has changed
      if (doc.containsKey("ph_limit") && ph_limit != doc["ph_limit"].as<float>()) {
        ph_limit = doc["ph_limit"].as<float>();
        configChanged = true;
      }
      
      // Check if PPM limit has changed
      if (doc.containsKey("ppm_limit") && ppm_limit != doc["ppm_limit"].as<int>()) {
        ppm_limit = doc["ppm_limit"].as<int>();
        configChanged = true;
      }
      
      // Check if pH min has changed
      if (doc.containsKey("ph_min") && ph_min != doc["ph_min"].as<float>()) {
        ph_min = doc["ph_min"].as<float>();
        configChanged = true;
      }
      
      // Check if PPM min has changed
      if (doc.containsKey("ppm_min") && ppm_min != doc["ppm_min"].as<int>()) {
        ppm_min = doc["ppm_min"].as<int>();
        configChanged = true;
      }
      
      // Check if scan interval has changed
      if (doc.containsKey("scan_interval") && scan_interval != doc["scan_interval"].as<int>()) {
        scan_interval = doc["scan_interval"].as<int>();
        configChanged = true;
      }
      
      // Check if fail safe has changed
      if (doc.containsKey("fail_safe") && fail_safe != doc["fail_safe"].as<int>()) {
        fail_safe = doc["fail_safe"].as<int>();
        configChanged = true;
      }
      
      // Log configuration changes
      if (configChanged) {
        String message = "Configuration updated: pH min=" + String(ph_min) + 
                        ", pH max=" + String(ph_limit) + 
                        ", PPM min=" + String(ppm_min) + 
                        ", PPM max=" + String(ppm_limit) + 
                        ", Scan interval=" + String(scan_interval) + " min";
        Serial.println(message);
        sendLogToFirebase(message);
      }
    }
  }
  client.stop();
}

// Function to initialize configuration values in Firebase
void initializeConfigInFirebase() {
  if (client.connect(FIREBASE_HOST, 443)) {
    // First check if config already exists
    String path = "/config.json?auth=" + String(FIREBASE_AUTH);
    client.println("GET " + path + " HTTP/1.1");
    client.println("Host: " + String(FIREBASE_HOST));
    client.println("Connection: close");
    client.println();

    // Wait for response
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 5000) { // Reduced timeout
        client.stop();
        return;
      }
    }

    // Read response and extract JSON body
    String response = "";
    bool jsonStarted = false;
    String line = "";
    
    while (client.available()) {
      char c = client.read();
      
      // Look for the blank line that separates headers from body
      if (c == '\r' && line.length() == 0) {
        // Skip this character
      } else if (c == '\n' && line.length() == 0) {
        // Empty line indicates the start of the JSON body
        jsonStarted = true;
        line = "";
      } else if (jsonStarted) {
        // If we've reached the JSON body, collect characters
        response += c;
      } else if (c == '\n') {
        // Reset line when we hit a newline
        line = "";
      } else {
        // Add character to current header line
        line += c;
      }
    }
    
    client.stop();
    
    // If we got a valid response and it's not "null", parse it
    if (response.length() > 0 && response != "null") {
      StaticJsonDocument<256> doc;
      DeserializationError error = deserializeJson(doc, response);
      if (!error) {
        // Update local config from Firebase if it exists
        if (doc.containsKey("ph_limit")) ph_limit = doc["ph_limit"].as<float>();
        if (doc.containsKey("ppm_limit")) ppm_limit = doc["ppm_limit"].as<int>();
        if (doc.containsKey("ph_min")) ph_min = doc["ph_min"].as<float>();
        if (doc.containsKey("ppm_min")) ppm_min = doc["ppm_min"].as<int>();
        if (doc.containsKey("scan_interval")) scan_interval = doc["scan_interval"].as<int>();
        if (doc.containsKey("fail_safe")) fail_safe = doc["fail_safe"].as<int>();
        
        Serial.println("Loaded existing configuration from Firebase");
        return;
      }
    }
    
    // If we get here, either the config doesn't exist or couldn't be parsed
    // Create a new config with current values
    if (client.connect(FIREBASE_HOST, 443)) {
      // Create a JSON document with default configuration values
      StaticJsonDocument<256> doc;
      doc["ph_limit"] = ph_limit;
      doc["ppm_limit"] = ppm_limit;
      doc["ph_min"] = ph_min;
      doc["ppm_min"] = ppm_min;
      doc["scan_interval"] = scan_interval;
      doc["fail_safe"] = fail_safe;
      
      String jsonStr;
      serializeJson(doc, jsonStr);
      
      // Send HTTP PUT request to create or update the config node
      client.println("PUT " + path + " HTTP/1.1");
      client.println("Host: " + String(FIREBASE_HOST));
      client.println("Connection: close");
      client.println("Content-Type: application/json");
      client.print("Content-Length: ");
      client.println(jsonStr.length());
      client.println();
      client.println(jsonStr);
      
      // Wait for response
      timeout = millis();
      while (client.available() == 0) {
        if (millis() - timeout > 5000) {
          client.stop();
          return;
        }
      }
      
      // Consume the response
      while (client.available()) {
        client.read();
      }
      
      Serial.println("Configuration initialized in Firebase");
    }
  }
  client.stop();
}

// Function to initialize pump control values in Firebase
void initializePumpControlsInFirebase() {
  if (client.connect(FIREBASE_HOST, 443)) {
    // Create a JSON document with default pump values
    StaticJsonDocument<256> doc;
    doc["water_pump"] = false;
    doc["water_pump_manual_control"] = false; // Add manual control flag
    doc["pump_a"] = false;
    doc["pump_b"] = false;
    doc["pump_c"] = false;
    doc["pump_d"] = false;
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    
    // Path to the pumps node in Firebase
    String path = "/pumps.json?auth=" + String(FIREBASE_AUTH);
    
    // Send HTTP PUT request to create or update the pumps node
    client.println("PUT " + path + " HTTP/1.1");
    client.println("Host: " + String(FIREBASE_HOST));
    client.println("Connection: close");
    client.println("Content-Type: application/json");
    client.print("Content-Length: ");
    client.println(jsonStr.length());
    client.println();
    client.println(jsonStr);
    
    // Wait for response
    unsigned long timeout = millis();
    while (client.available() == 0) {
      if (millis() - timeout > 5000) { // Reduced timeout
        client.stop();
        return;
      }
    }
    
    // Consume the response
    while (client.available()) {
      client.read();
    }
    
    Serial.println("Pump controls initialized in Firebase");
  }
  client.stop();
}

void setup() {
  Serial.begin(9600);
  
  // Set up all pump pins as outputs
  pinMode(waterPumpPin, OUTPUT);
  pinMode(solutionAPin, OUTPUT);
  pinMode(solutionBPin, OUTPUT);
  pinMode(solutionCPin, OUTPUT);
  pinMode(solutionDPin, OUTPUT);
  
  // Set up sensor pins
  pinMode(floaterSwitchPin, INPUT_PULLUP);  // From floatswitch.ino
  pinMode(phSensorPin, INPUT);
  pinMode(tdsSensorPin, INPUT);
  
  // Initialize temperature sensor
  sensors.begin();
  
  // Turn off all pumps initially
  digitalWrite(waterPumpPin, LOW);
  digitalWrite(solutionAPin, LOW);
  digitalWrite(solutionBPin, LOW);
  digitalWrite(solutionCPin, LOW);
  digitalWrite(solutionDPin, LOW);
  
  // Connect to WiFi
  Serial.print("Connecting to WiFi");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(300);
  }
  Serial.println();
  Serial.print("Connected with IP: ");
  Serial.println(WiFi.localIP());
  
  // Initialize pump controls in Firebase
  initializePumpControlsInFirebase();
  
  // Initialize configuration values in Firebase
  initializeConfigInFirebase();
  
  // Send startup log message
  sendLogToFirebase("System started with default configuration: pH min=" + String(ph_min) + 
                   ", pH max=" + String(ph_limit) + ", PPM min=" + String(ppm_min) + 
                   ", PPM max=" + String(ppm_limit) + ", Scan interval=" + String(scan_interval) + " min");
  
  // Initial sensor reading
  updateSensorsAndControl(true);
}

void loop() {
  // Check for configuration changes less frequently to avoid interference with pump operations
  static unsigned long lastConfigReadTime = 0;
  if (millis() - lastConfigReadTime >= 30000) { // Check every 30 seconds
    readConfigFromFirebase();
    lastConfigReadTime = millis();
  }
  
  // Update sensor values frequently but with enough time between readings
  static unsigned long lastSensorUpdateTime = 0;
  unsigned long sensorUpdateInterval = 5000; // Update sensors every 5 seconds
  
  if (millis() - lastSensorUpdateTime >= sensorUpdateInterval) {
    updateSensorsAndControl(false); // Update sensors without performing control
    lastSensorUpdateTime = millis();
  }
  
  // Perform control actions at the scan interval
  // Use scan_interval from Firebase if it's greater than 0, otherwise use default
  // Convert scan_interval from minutes to milliseconds
  static unsigned long lastControlTime = 0;
  unsigned long currentSensorInterval = (scan_interval > 0) ? scan_interval * 60000 : sensorReadInterval;
  
  // Only perform control if no pumps are currently running (except water pump)
  // This ensures one operation completes before starting another
  if (millis() - lastControlTime >= currentSensorInterval && 
      !pumpARunning && !pumpBRunning && !pumpCRunning && !pumpDRunning) {
    updateSensorsAndControl(true); // Update sensors and perform control
    lastControlTime = millis();
  }
  
  // Check for pump commands from Firebase more frequently
  // Modified to check even when pumps are running, for manual control
  static unsigned long lastPumpCommandTime = 0;
  if (millis() - lastPumpCommandTime >= 2000) { // Check every 2 seconds instead of 5
    readPumpCommandsFromFirebase();
    lastPumpCommandTime = millis();
  }
  
  // Check if any pump has been running too long (failsafe)
  // This prevents pumps from running indefinitely if something goes wrong
  unsigned long currentTime = millis();
  unsigned long maxPumpRunTime = 60000; // Maximum 1 minute continuous run time
  
  if (pumpARunning && (currentTime - pumpAStartTime > maxPumpRunTime)) {
    digitalWrite(solutionAPin, LOW);
    pumpARunning = false;
    String message = "FAILSAFE: Pump A turned off after running for too long";
    Serial.println(message);
    sendLogToFirebase(message);
    updatePumpStatusInFirebase();
    delay(1000); // Reduced delay to allow system to stabilize before next check
  }
  
  if (pumpBRunning && (currentTime - pumpBStartTime > maxPumpRunTime)) {
    digitalWrite(solutionBPin, LOW);
    pumpBRunning = false;
    String message = "FAILSAFE: Pump B turned off after running for too long";
    Serial.println(message);
    sendLogToFirebase(message);
    updatePumpStatusInFirebase();
    delay(1000); // Reduced delay
  }
  
  if (pumpCRunning && (currentTime - pumpCStartTime > maxPumpRunTime)) {
    digitalWrite(solutionCPin, LOW);
    pumpCRunning = false;
    String message = "FAILSAFE: Pump C turned off after running for too long";
    Serial.println(message);
    sendLogToFirebase(message);
    updatePumpStatusInFirebase();
    delay(1000); // Reduced delay
  }
  
  if (pumpDRunning && (currentTime - pumpDStartTime > maxPumpRunTime)) {
    digitalWrite(solutionDPin, LOW);
    pumpDRunning = false;
    String message = "FAILSAFE: Pump D turned off after running for too long";
    Serial.println(message);
    sendLogToFirebase(message);
    updatePumpStatusInFirebase();
    delay(1000); // Reduced delay
  }
  
  // Small delay to avoid excessive processing but still maintain responsiveness
  delay(50); // Reduced delay for more responsive control
  yield(); // Allow WiFi processing
}
